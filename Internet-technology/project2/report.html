<!DOCTYPE html>
<html>
<head>
<title>report.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E5%BA%94%E7%94%A8%E5%B1%82%E5%AE%9E%E9%AA%8C-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A">实验二 应用层实验 实验报告</h1>
<table>
<thead>
<tr>
<th>学院</th>
<th>班级</th>
<th>学号</th>
<th>姓名</th>
<th>指导教师</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机科学与工程学院</td>
<td>计硕2109</td>
<td>2171960</td>
<td>徐文昊</td>
<td>刘铮</td>
</tr>
</tbody>
</table>
<p>本次实验选择实现一个简单的 Web Server.</p>
<hr>
<ul>
<li><a href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E5%BA%94%E7%94%A8%E5%B1%82%E5%AE%9E%E9%AA%8C-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A">实验二 应用层实验 实验报告</a>
<ul>
<li><a href="#%E7%AE%80%E6%98%93%E5%A4%9A%E7%BA%BF%E7%A8%8B-http-%E6%9C%8D%E5%8A%A1%E5%99%A8">简易多线程 HTTP 服务器</a></li>
<li><a href="#%E5%8A%9F%E8%83%BD%E5%B1%95%E7%A4%BA">功能展示</a>
<ul>
<li><a href="#%E9%A6%96%E9%A1%B5">首页</a></li>
<li><a href="#%E5%AD%90%E9%A1%B5%E9%9D%A2">子页面</a></li>
</ul>
</li>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">快速开始</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a>
<ul>
<li><a href="#cs-%E6%A8%A1%E5%9E%8B">C/S 模型</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA">程序的输入与输出</a>
<ul>
<li><a href="#http-request">HTTP Request</a></li>
<li><a href="#http-response">HTTP Response</a></li>
</ul>
</li>
<li><a href="#%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B">处理过程</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0-socket-%E5%B9%B6%E7%9B%91%E5%90%AC%E6%B6%88%E6%81%AF">构造 Socket 并监听消息</a></li>
<li><a href="#%E5%A4%84%E7%90%86-http-request-%E8%AF%B7%E6%B1%82">处理 HTTP Request 请求</a>
<ul>
<li><a href="#%E8%A7%A3%E6%9E%90-http-%E8%AF%B7%E6%B1%82">解析 HTTP 请求</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6">获取请求的资源文件</a></li>
<li><a href="#%E6%9E%84%E9%80%A0-http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">构造 HTTP 响应报文</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">发送响应报文</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
<h2 id="%E7%AE%80%E6%98%93%E5%A4%9A%E7%BA%BF%E7%A8%8B-http-%E6%9C%8D%E5%8A%A1%E5%99%A8">简易多线程 HTTP 服务器</h2>
<p>本服务器功能特性如下。</p>
<ul>
<li>Using Socket in Python and file based</li>
<li>基于线程池的多线程</li>
<li>支持 HTTP GET 请求 (RFC 7231)</li>
<li>支持静态资源内容请求</li>
<li>MIME 类型支持</li>
<li>支持 200, 206 和 404 HTTP Response Status Code</li>
<li>支持 HTTP GET 请求的单线程断点续传 (single Range HTTP GET Request, RFC 2616/RFC 7233)</li>
</ul>
<h2 id="%E5%8A%9F%E8%83%BD%E5%B1%95%E7%A4%BA">功能展示</h2>
<p>在 <code>./static_files/</code> 文件夹下放入由 Hexo 生成的纯静态网页后的效果。P.S. 你可以放入任何纯静态的网页内容.</p>
<h3 id="%E9%A6%96%E9%A1%B5">首页</h3>
<p><a href="https://imgtu.com/i/IgiagU"><img src="https://z3.ax1x.com/2021/11/15/IgiagU.md.png" alt="IgiagU.md.png"></a></p>
<h3 id="%E5%AD%90%E9%A1%B5%E9%9D%A2">子页面</h3>
<p><a href="https://imgtu.com/i/IgiBDJ"><img src="https://z3.ax1x.com/2021/11/15/IgiBDJ.md.png" alt="IgiBDJ.md.png"></a></p>
<p>其效果与本人用 Ngnix 部署的个人网站等效，浏览请 <a href="https://www.xuwhao.top">点击此处</a>。</p>
<h2 id="%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">快速开始</h2>
<ol>
<li>
<p>安装 python2.7<br>
自行安装. 如没有集成开发环境等也可自行安装，如 PyCharm.</p>
</li>
<li>
<p>在 HTTP Server 目录下安装相关依赖</p>
<pre class="hljs"><code><div>pip install -r requirements.txt
</div></code></pre>
</li>
<li>
<p>启动服务器</p>
<pre class="hljs"><code><div><span class="hljs-comment"># entry point is './run.py'</span>
python run.py
</div></code></pre>
</li>
<li>
<p>在浏览器中打开对应网页</p>
<ul>
<li>open url: <a href="http://localhost:5555/test_1.txt">http://localhost:5555/test_1.txt</a></li>
<li>open url: <a href="http://localhost:5555/test_2.html">http://localhost:5555/test_2.html</a></li>
<li>open url: <a href="http://localhost:5555/test_3.html">http://localhost:5555/test_3.html</a></li>
<li>open url: <a href="http://localhost:5555/test_4.gif">http://localhost:5555/test_4.gif</a></li>
<li>open url: <a href="http://localhost:5555/test_5.mp4">http://localhost:5555/test_5.mp4</a></li>
</ul>
</li>
<li>
<p>everything works?<br>
打开浏览器的开发者模式，观察本服务器的各种特性。</p>
</li>
</ol>
<h2 id="%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</h2>
<h3 id="cs-%E6%A8%A1%E5%9E%8B">C/S 模型</h3>
<p>Client/Server 模型的时序图如下。</p>
<pre><code class="language-mermaid"><div class="mermaid">sequenceDiagram
    participant S as Server
    participant C as Client
    C->>S: HTTP Request
    S-->>S: Process
    S-->>C: HTTP Response
</div></code></pre>
<p>从图中我们可以看出，实现一个 HTTP Server，需要监听并响应客户端的 HTTP 请求。</p>
<h3 id="%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA">程序的输入与输出</h3>
<p>一个程序总会有输入、处理与输出的过程。而作为一个 HTTP Server，输入自然就是 HTTP Request 请求报文，而输出就是 HTTP Response 响应报文。我们有必要了解这两个报文的细节，从而明确我们的处理过程究竟是一个什么逻辑。下面将先阐述两个报文的细节，以说明我们需要做的工作。</p>
<h4 id="http-request">HTTP Request</h4>
<p>一个 HTTP 请求报文由请求行（Request Line）、请求头部（Header）、空行(&lt;CR&gt;&lt;LF&gt;)和请求数据4个部分组成,请求数据不在 GET 方法中使用，而是在 POST 方法中使用。当 HTTP 请求报文携带请求数据时，必须在 Header 中指明 Content-Length。本服务器仅考虑实现 GET 请求。</p>
<p>下面是一则 HTTP GET 请求。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: localhost:5555
<span class="hljs-attribute">Connection</span>: keep-alive
<span class="hljs-attribute">sec-ch-ua</span>: "Google Chrome";v="95", "Chromium";v="95", ";Not A Brand";v="99"
<span class="hljs-attribute">sec-ch-ua-mobile</span>: ?0
<span class="hljs-attribute">sec-ch-ua-platform</span>: "Windows"
<span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1
<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36
<span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
<span class="hljs-attribute">Sec-Fetch-Site</span>: none
<span class="hljs-attribute">Sec-Fetch-Mode</span>: navigate
<span class="hljs-attribute">Sec-Fetch-User</span>: ?1
<span class="hljs-attribute">Sec-Fetch-Dest</span>: document
<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate, br
<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.9
<span class="hljs-attribute">Cookie</span>: _ga=GA1.1.1705856518.1631602913; Hm_lvt_0d04419c5b1bb2e0a76b92ec342502b4=1636898877; _gid=GA1.1.2017212840.1636898877; Hm_lpvt_0d04419c5b1bb2e0a76b92ec342502b4=1636906589
&lt;CR&gt;&lt;LF&gt;
</div></code></pre>
<p>其中第一行是请求行，其中 &quot;GET&quot; 是请求方法，表示客户端以 GET 方式申请资源，GET 请求被认为是幂等的，即多次、连续发送的请求结果应一致。紧随其后的是资源 URI 与 HTTP 版本号。<br>
第二行开始都是 HTTP 请求的头部字段。<br>
在本服务器中，需要根据 HTTP GET 请求中的 Request URI 与 Header，来寻找正确的资源并进行处理，写入 HTTP Response 报文中返回给服务器端。</p>
<h4 id="http-response">HTTP Response</h4>
<p>HTTP Response 响应报文分为响应行，Header 响应头，空行和响应体 Body 组成。下面是一则 HTTP Response 响应报文。</p>
<pre class="hljs"><code><div>HTTP/1.1 <span class="hljs-number">206</span> Partial Content
<span class="hljs-attribute">Content-Length</span>: 1155802
<span class="hljs-attribute">Content-type</span>: video/mp4
<span class="hljs-attribute">Accept-Ranges</span>: bytes
<span class="hljs-attribute">Content-Range</span>: bytes 0-1155801/1155802
&lt;CR&gt;&lt;LF&gt;
[Response Body for binary data]
</div></code></pre>
<p>其中第一行是响应行。第一个参数表明了 HTTP 协议的版本。随后的参数是 HTTP 状态码，206 代表 Partial Content. 其他的还有 200 OK，404 Not Found 等。随后一直到空行都是 Response Header. <code>Content-Length</code> 代表 Body 的 长度，<code>Content-type</code> 指出了资源的 MIME Type. <code>Accept-Ranges: bytes</code> 表示服务器支持 Partial Request. 本 HTTP 服务器的断点续传及基于 HTTP Request 的 <code>Range</code> 头，HTTP Response 的 <code>Content-Range</code> 和 <code>Accept-Ranges</code> 头实现。</p>
<h3 id="%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B">处理过程</h3>
<p>首先明确，我们要做的就是：</p>
<ol>
<li>通过 Socket 拿到 HTTP 请求，在本服务器中暂时只考虑 GET请求。</li>
<li>根据 Request Line 中的 URI 寻找对应资源。</li>
<li>根据资源的查找结果，构造 HTTP Response 响应报文。</li>
<li>通过 Socket 发送给浏览</li>
</ol>
<p>流程如下图所示。</p>
<pre><code class="language-mermaid"><div class="mermaid">flowchart TB
    Socket-->Recv(Receive Request)-->get_file(Get Resources)-->Build(Build Response)-->Send(Send Response)
</div></code></pre>
<p>下面给出各个部分的实现</p>
<h4 id="%E6%9E%84%E9%80%A0-socket-%E5%B9%B6%E7%9B%91%E5%90%AC%E6%B6%88%E6%81%AF">构造 Socket 并监听消息</h4>
<p>流程如下。</p>
<pre><code class="language-mermaid"><div class="mermaid">flowchart TB
    subgraph Server
    SSocket(Server Socket)-->Bind-->Listen-->Accept-->SR(Receive)-->SS(Send)-->Accept
    end
    subgraph Client
    CSocket(Client Socket)-->Connect-->CS(Send)-->CR(Receive)
    end
    Connect-->Accept
</div></code></pre>
<p>具体实现如下。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(host, port)</span>:</span>
    address = (host, port)
    serversock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    serversock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)
    serversock.bind(address)
    serversock.listen(SOCKET_BACKLOG_SIZE)

    Log.info(<span class="hljs-string">'StaticHttpServer started on %s:%s'</span> % (host, port, ))

    pool = ThreadPool(THREAD_POOL_SIZE)

    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        Log.debug(<span class="hljs-string">'Waiting for connection...'</span>)

        clientsock, addr = serversock.accept()
        Log.debug(<span class="hljs-string">'Connected from: %s'</span>, addr)

        pool.add_task(handle_request, clientsock)
</div></code></pre>
<p>首先创建一个 Socket, 然后将其绑定到指定的主机和端口上，调用 <code>accept()</code> 函数等待客户端连接。若建立连接，则在线程池中选择一个线程为本次连接服务。线程池的实现不在本次应用层实验范围中，不予赘述。可以自行查看本服务器源代码了解。</p>
<h4 id="%E5%A4%84%E7%90%86-http-request-%E8%AF%B7%E6%B1%82">处理 HTTP Request 请求</h4>
<p>在客户端连接以后，我们需要通过 <code>socket.recv(BUFFER_SIZE)</code> 函数来接受 <code>GET</code> 请求。随后进行对应的处理过程。整个处理过程见如下代码。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_request</span><span class="hljs-params">(clientsock)</span>:</span>

    data = clientsock.recv(RECV_BUFSIZ)

    Log.debug(<span class="hljs-string">'Request received:\n%s'</span>, data)

    <span class="hljs-comment"># decode http get request</span>
    request = parse_http_request(data)

    <span class="hljs-comment"># request for a default file named "index.html" instead of a directory</span>
    request_uri = request.request_uri
    <span class="hljs-keyword">if</span> request_uri.endswith(<span class="hljs-string">'/'</span>):
        request_uri = request_uri + <span class="hljs-string">'index.html'</span>

    <span class="hljs-comment"># this server is based on file.Any resources requested are treated as files. </span>
    <span class="hljs-comment"># Collect some information about the file</span>
    <span class="hljs-comment"># such as whether the file exists, file size, the MIME type</span>
    file = get_file(request_uri)

    <span class="hljs-comment"># return 206 if the request is a range-request</span>
    <span class="hljs-keyword">if</span> file.exists <span class="hljs-keyword">and</span> request.is_range_requested():
        response = HttpResponse(protocol=request.protocol, status_code=<span class="hljs-number">206</span>,
                                range=request.get_range())
        response.file = file

    <span class="hljs-comment"># return 200 if file exists</span>
    <span class="hljs-keyword">elif</span> file.exists:
        response = HttpResponse(protocol=request.protocol, status_code=<span class="hljs-number">200</span>)
        response.file = file
    
    <span class="hljs-comment"># return 404, file not found</span>
    <span class="hljs-keyword">else</span>:

        response = HttpResponse(protocol=request.protocol, status_code=<span class="hljs-number">404</span>)
        response.headers[<span class="hljs-string">'Content-type'</span>] = <span class="hljs-string">'text/plain'</span>
        response.content = <span class="hljs-string">'This file does not exist!'</span>

    Log.info(<span class="hljs-string">'GET %s %s %s %s'</span>,
             request.request_uri, request.protocol, request.get_range(), response.status_code)
    
    <span class="hljs-comment"># write http response to the socket</span>
    response.write_to(clientsock)
    clientsock.close()
</div></code></pre>
<h5 id="%E8%A7%A3%E6%9E%90-http-%E8%AF%B7%E6%B1%82">解析 HTTP 请求</h5>
<p>以一则 <code>GET</code> 请求为例，看程序如何解析。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_http_request</span><span class="hljs-params">(data)</span>:</span>
    <span class="hljs-comment"># guard, check input parameters</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:
        error = <span class="hljs-string">'Input parameter data must be provided.'</span>
        Log.error(error)
        <span class="hljs-keyword">raise</span> HttpParseException(error)

    data_lines = data.splitlines(<span class="hljs-literal">False</span>)

    request_line = data_lines[<span class="hljs-number">0</span>]
    request_cmpts = request_line.split(<span class="hljs-string">' '</span>)

    <span class="hljs-keyword">if</span> len(request_cmpts) != <span class="hljs-number">3</span>:
        error = <span class="hljs-string">'Cannot parse HTTP request line: %s'</span> % request_line
        Log.error(error)
        <span class="hljs-keyword">raise</span> HttpParseException(error)

    method, request_uri, protocol = request_cmpts[<span class="hljs-number">0</span>], request_cmpts[<span class="hljs-number">1</span>], request_cmpts[<span class="hljs-number">2</span>]
    headers = {}

    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data_lines[<span class="hljs-number">1</span>:]:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
            <span class="hljs-keyword">break</span>

        line_cmpts = line.split(<span class="hljs-string">': '</span>)

        <span class="hljs-keyword">if</span> len(line_cmpts) != <span class="hljs-number">2</span>:
            <span class="hljs-keyword">raise</span> HttpParseException(<span class="hljs-string">'Cannot parse HTTP header line: %s'</span> % line)

        key, value = line_cmpts[<span class="hljs-number">0</span>], line_cmpts[<span class="hljs-number">1</span>]
        headers[key] = value

    <span class="hljs-keyword">return</span> HttpRequest(method, request_uri, protocol, headers)
</div></code></pre>
<p><code>GET</code> 请求如下。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">GET</span> <span class="hljs-string">/images/top_ys/ys_khsv.jpg</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: localhost:5555
<span class="hljs-attribute">Connection</span>: keep-alive
<span class="hljs-attribute">sec-ch-ua</span>: "Google Chrome";v="95", "Chromium";v="95", ";Not A Brand";v="99"
<span class="hljs-attribute">sec-ch-ua-mobile</span>: ?0
<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36
<span class="hljs-attribute">sec-ch-ua-platform</span>: "Windows"
<span class="hljs-attribute">Accept</span>: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
<span class="hljs-attribute">Sec-Fetch-Site</span>: same-origin
<span class="hljs-attribute">Sec-Fetch-Mode</span>: no-cors
<span class="hljs-attribute">Sec-Fetch-Dest</span>: image
<span class="hljs-attribute">Referer</span>: http://localhost:5555/index.html
<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate, br
<span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.9
&lt;CR&gt;&lt;LF&gt;
</div></code></pre>
<p>首先，按行分割，取到 <code>Request Line</code>。</p>
<pre class="hljs"><code><div>data_lines = data.splitlines(<span class="hljs-literal">False</span>)
request_line = data_lines[<span class="hljs-number">0</span>]

<span class="hljs-comment"># 此时变量值</span>
<span class="hljs-comment"># request_line = "GET /images/top_ys/ys_khsv.jpg HTTP/1.1"</span>
</div></code></pre>
<p>再根据空格分割，得到请求方法，资源 URI 及本次协议版本。</p>
<pre class="hljs"><code><div>method, request_uri, protocol = request_cmpts[<span class="hljs-number">0</span>], request_cmpts[<span class="hljs-number">1</span>], request_cmpts[<span class="hljs-number">2</span>]

<span class="hljs-comment"># method = "GET"</span>
<span class="hljs-comment"># request_uri = "/images/top_ys/ys_khsv.jpg"</span>
<span class="hljs-comment"># protocol = "HTTP/1.1"</span>
</div></code></pre>
<p>接下来每一行都是一条 Header，在循环中用冒号 <code>:</code> 分割，放入字典 (dict) 类型变量 <code>headers</code> 中。</p>
<p>最后返回一个 HttpRequest 对象，包含上面提到的这些变量即可。</p>
<h5 id="%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6">获取请求的资源文件</h5>
<p>通过 python 的 os 类库以及 mimetypes 类库，判断文件的大小及 MIME Type. 构造 File 对象返回，后续作为 Response Body 写给浏览器。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_file</span><span class="hljs-params">(request_uri)</span>:</span>
    fn = STATIC_FILES_DIR + request_uri
    fsize = <span class="hljs-literal">None</span>
    exists = <span class="hljs-literal">False</span>
    mime_type = <span class="hljs-string">''</span>

    <span class="hljs-keyword">try</span>:
        fsize = os.path.getsize(fn)
        exists = <span class="hljs-literal">True</span>
        type, encoding = mimetypes.guess_type(request_uri)
        <span class="hljs-keyword">if</span> type:
            mime_type = type
    <span class="hljs-keyword">except</span>:
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">return</span> File(request_uri, fn, fsize, exists, mime_type)
</div></code></pre>
<h5 id="%E6%9E%84%E9%80%A0-http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">构造 HTTP 响应报文</h5>
<p>首先构造一个 HttpResponse 对象，里面保存本次返回的状态码、协议版本、Headers 头的字典、所指向的资源文件等信息。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpResponse</span><span class="hljs-params">(object)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, protocol, status_code, range=None)</span>:</span>
        <span class="hljs-keyword">assert</span> status_code <span class="hljs-keyword">in</span> HTTP_STATUS_CODES, <span class="hljs-string">'Unknown status code.'</span>

        self.protocol = protocol
        self.status_code = status_code
        self.headers = {}
        self.range = range
        self.content = <span class="hljs-string">''</span>
        self.file = <span class="hljs-literal">None</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'HttpRequest (protocol=%s, status_code=%s)'</span> % \
               (self.protocol, self.status_code)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_to</span><span class="hljs-params">(self, output)</span>:</span>
      <span class="hljs-comment"># 省略...</span>
</div></code></pre>
<p>这个对象拥有一个方法，向 Socket 写入 Response 报文。</p>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_to</span><span class="hljs-params">(self, output)</span>:</span>
        <span class="hljs-keyword">if</span> self.file:
            self.headers[<span class="hljs-string">'Content-type'</span>] = self.file.mime_type
            self.headers[<span class="hljs-string">'Content-Length'</span>] = self.file.file_size
            self.headers[<span class="hljs-string">'Accept-Ranges'</span>] = <span class="hljs-string">'bytes'</span>

            <span class="hljs-keyword">if</span> self.range:
                range_start, range_end = self.file.calculate_range(self.range)

                self.headers[<span class="hljs-string">'Content-Range'</span>] = <span class="hljs-string">'bytes %s-%s/%s'</span> % (range_start, range_end,
                                                                    self.file.file_size)
                self.headers[<span class="hljs-string">'Content-Length'</span>] = range_end - range_start + <span class="hljs-number">1</span>

        response_msg = render_http_response(self)

        output.sendall(response_msg)

        Log.debug(<span class="hljs-string">'Response:\n%s'</span>, response_msg)

        <span class="hljs-keyword">if</span> self.file:
            self.file.stream_to(output, range=self.file.calculate_range(self.range))
</div></code></pre>
<p>其内部先构造了 Response Header 的响应头字典，然后根据 Response Line 和 Header，构造除了 Body 外的响应报文部分（特殊情况下 Body 的内容在 content 变量中），，并传输给浏览器。下面是构造过程。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render_http_response</span><span class="hljs-params">(response)</span>:</span>
    ret_val = []

    response_line = <span class="hljs-string">'%s %s %s'</span> % (response.protocol, response.status_code,
                                  HTTP_STATUS_CODES[response.status_code][<span class="hljs-number">0</span>])

    ret_val.append(response_line)

    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> response.headers.iteritems():
        header_line = <span class="hljs-string">'%s: %s'</span> % (key, value)
        ret_val.append(header_line)

    ret_val.append(<span class="hljs-string">''</span>)

    <span class="hljs-keyword">if</span> response.content:
        ret_val.append(response.content)
    <span class="hljs-keyword">else</span>:
        ret_val.append(<span class="hljs-string">''</span>)

    <span class="hljs-keyword">return</span> <span class="hljs-string">'\n'</span>.join(ret_val)
</div></code></pre>
<p>即把字典拼接成字符串即可。</p>
<h5 id="%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">发送响应报文</h5>
<p>将 Response Line 与 Response Header 传输给浏览器。</p>
<pre class="hljs"><code><div>response_msg = render_http_response(self)
output.sendall(response_msg)
</div></code></pre>
<p>将 Body 之前的响应报文写给服务器后，将 Body，也就是请求的文件写给浏览器。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> self.file:
    self.file.stream_to(output, range=self.file.calculate_range(self.range))
</div></code></pre>
<p>在 <code>handle_request</code> 函数中调用 <code>write_to</code> 函数即可像客户端传输响应报文。最后关闭本次连接即可。</p>
<h2 id="%E6%80%BB%E7%BB%93">总结</h2>
<p>本次实验根据应用层 HTTP 协议，实现了一个支持静态资源响应的 HTTP 服务器。在本次实验中，对 HTTP 协议有了更深入的了解，Coding 能力也得到了提高。当然此次实验还有不足的地方。考虑以后可以增加如下特性。</p>
<ul>
<li>Command Line arguments for HTTP Server</li>
<li>通过 CGI 支持 GET 请求携带 URL 参数</li>
<li>通过 CGI 支持 POST、PUT 等其他非幂等的 HTTP 请求</li>
</ul>

</body>
</html>
